###############################################################################
#  Sonos & Apple TV Multimedia Control Package                                #
#  Uses Script + Helpers for Sonos Alarm Info Calculation (User Version)      #
#  Includes Apple TV Idle Timeout                                             #
#  Uses Event Trigger for Sonos Alarm Updates                                 #
#  FIXED: Corrected variable definitions in debug/disable scripts             #
#  FIXED: Corrected Apple TV automation conditions                            #
#  FIXED: Removed confusing debug message line                                #
#  UPDATED: Default display entity ID                                         #
#  FIXED: Corrected 'today' undefined error in debug_sonos_alarms script      #
#  FIXED: Corrected final summary logic in debug_sonos_alarms script          #
#  FIXED: Corrected variable definition in evening_alarm_check_notification   #
#  SIMPLIFIED: evening_alarm_check_notification to check only soonest alarm   #
#  FIXED: Corrected attribute access in disable_tomorrows_sonos_alarms        #
###############################################################################

# The soonest-alarm helpers and their update script are now deprecated and replaced by the centralized sensor.
# All scripts now use 'sensor.sonos_alarms_for_tomorrow' for tomorrow's alarm logic.
# See the 'Sonos Alarms for Tomorrow' sensor for all relevant attributes and debug info.
# All alarm-identification logic is now centralized for maintainability and robustness.

############################
#  USER HELPERS            #
############################
input_select:
  sonos_group_selector:
    name: Sonos group selector
    options:
      - Select room
      - Living
      - Dining
      - Kitchen
      - Bath
      - Bedroom
input_boolean:
  # Sonos Helpers
  sonos_auto_group_enabled:
    name: Sonos Auto-Group Enabled
    icon: mdi:account-music
    initial: true

  sonos_alarm_notifications:
    name: Sonos Alarm Notifications Enabled
    icon: mdi:bell-ring-outline
    initial: on

  # Apple TV Helpers
  apple_tv_no_auto_off:
    name: Apple TV - Prevent Auto Off
    icon: mdi:television-pause
    initial: false

input_number:
  sonos_default_volume:
    name: Sonos Default Volume
    icon: mdi:volume-medium
    min: 0
    max: 1
    step: 0.05
    unit_of_measurement: "vol"
    mode: slider

input_text:
  # Shared helper for push notifications
  notify_target_device_id:
    name: Device-ID for Multimedia Pushes
    icon: mdi:cellphone
    mode: text # Ensure mode is text
    initial: a09d6105c2e90cc42e7264679d34b17a  #  <-- REPLACE with your phone's ID

  # DEPRECATED: soonest_sonos_alarm_entity_id helper is no longer needed.
  # soonest_sonos_alarm_entity_id:
  #   name: Soonest Sonos Alarm Entity ID
  #   icon: mdi:identifier
  #   initial: "None"

  # NEW: Apple TV entity ID helpers (configurable)
  apple_tv_entity_id:
    name: Apple TV Entity ID
    icon: mdi:apple
    initial: media_player.living_room_apple_tv
    mode: text

  apple_tv_display_entity_id:
    name: Apple TV Display Entity ID
    icon: mdi:television
    initial: media_player.living_room_samsung_q60 # UPDATED Default
    mode: text

  # NEW: Helper to store disabled Sonos alarms for re-enabling later
  sonos_alarms_disabled_for_tomorrow:
    name: Sonos Alarms Disabled for Tomorrow
    icon: mdi:alarm-off
    mode: text
    initial: ""

  # Store the last manually toggled alarm entity_id for chip functionality
  sonos_manually_toggled_alarm:
    name: Sonos Manually Toggled Alarm
    icon: mdi:alarm-check
    mode: text
    initial: ""




############################

input_datetime:
  apple_tv_last_playing:
    name: Apple TV Last Playing
    has_date: true
    has_time: true

#  SPEAKER GROUP           #
############################
group:
  sonos_all:
    name: All Sonos Speakers
    entities:
      - media_player.living_room
      - media_player.dining_room
      - media_player.kitchen
      - media_player.bath
      - media_player.bedroom



############################
#  TEMPLATE SENSORS        #
############################
template:
  sensor:
    - name: "Sonos Alarms for Tomorrow"
      unique_id: sonos_alarms_for_tomorrow
      icon: mdi:alarm-multiple
      state: >
        {{ state_attr('sensor.sonos_alarms_for_tomorrow', 'alarm_count') | default(0) }} alarm(s) scheduled for tomorrow.
      attributes:
        all_alarms_data: >
          {%- set tomorrow_date_obj = (now() + timedelta(days=1)).date() -%}
          {%- set ns = namespace(collected_alarms_for_tomorrow = []) -%}
          {%- set now_dt = now() -%}

          {# Iterate through Sonos alarm switches that are 'on' and have a 'time' attribute (lowercase) #}
          {%- for alarm_entity in states.switch
              | selectattr('entity_id','search','sonos_alarm_')
              | selectattr('state','eq','on') -%}
            {%- set time_str = alarm_entity.attributes.get('time') -%}
            {%- if not time_str %}{% continue %}{% endif -%}

            {%- set recurrence = (alarm_entity.attributes.get('recurrence') | default('DAILY')) | upper -%}
            {%- set base_time = today_at(time_str) -%}

            {# Check recurrence for up to 7 days ahead #}
            {%- for i in range(7) -%}
              {%- set check_datetime = base_time + timedelta(days=i) -%}
              {%- set weekday_sonos = check_datetime.isoweekday() % 7 -%} {# 0=Sun, 1=Mon, ..., 6=Sat #}
              {%- set day_matches_recurrence = false -%}

              {%- if recurrence == 'DAILY' %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence == 'WEEKDAYS' and 1 <= weekday_sonos <= 5 %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence == 'WEEKENDS' and (weekday_sonos == 0 or weekday_sonos == 6) %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence.startswith('ON_') -%}
                {%- set days_in_recurrence = recurrence.split('_',1)[1] -%}
                {%- if weekday_sonos|string in days_in_recurrence %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- endif -%}

              {# If the alarm is scheduled for this checked day and is in the future #}
              {%- if day_matches_recurrence and check_datetime > now_dt -%}
                {# If this checked day is tomorrow #}
                {%- if check_datetime.date() == tomorrow_date_obj -%}
                  {%- set existing_entity_ids = ns.collected_alarms_for_tomorrow | map(attribute='entity_id') | list -%}
                  {%- if alarm_entity.entity_id not in existing_entity_ids -%}
                    {%- set alarm_item = {
                        'entity_id': alarm_entity.entity_id,
                        'time': time_str,
                        'friendly_name': alarm_entity.attributes.get('friendly_name') | default(alarm_entity.name),
                        'timestamp': check_datetime.timestamp(),
                        'room': area_name(alarm_entity.entity_id) | default('Unknown')
                    } -%}
                    {%- set ns.collected_alarms_for_tomorrow = ns.collected_alarms_for_tomorrow + [alarm_item] -%}
                  {%- endif -%}
                  {# Only break if we found a match for tomorrow #}
                  {%- break -%}
                {%- endif -%}
              {%- endif -%}
            {%- endfor -%} {# End of i in range(7) loop #}
          {%- endfor -%} {# End of alarm_entity loop #}

          {# Post-loop processing #}
          {%- set sorted_alarms = ns.collected_alarms_for_tomorrow | sort(attribute='timestamp') -%}

          {%- set earliest_alarm_item = (sorted_alarms | first) if sorted_alarms else none -%}
          {%- set earliest_ts = earliest_alarm_item.timestamp if earliest_alarm_item else none -%}
          {%- set earliest_dt_local = as_datetime(earliest_ts) if earliest_ts is not none else none %}

          {%- set output_data = {
              'alarm_count': sorted_alarms | length,
              'alarm_entities': sorted_alarms | map(attribute='entity_id') | list,
              'friendly_names': sorted_alarms | map(attribute='friendly_name') | list,
              'rooms': sorted_alarms | map(attribute='room') | unique | list,
              'earliest_alarm_timestamp_tomorrow': earliest_ts,
              'earliest_alarm_time_tomorrow': as_local(as_datetime(earliest_ts)).strftime('%H:%M:%S') if earliest_ts is not none else 'None',
              'raw_alarm_list_sorted': sorted_alarms,
              'debug_tomorrow_date_obj': tomorrow_date_obj.isoformat(),
              'debug_processing_time_utc': now().isoformat()
          } -%}
          {{- output_data -}}
        alarm_count: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('alarm_count', 0) if data is mapping else 0 }}
        alarm_entities: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('alarm_entities', []) if data is mapping else [] }}
        friendly_names: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('friendly_names', []) if data is mapping else [] }}
        earliest_alarm_time_tomorrow: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('earliest_alarm_time_tomorrow', 'None') if data is mapping else 'None' }}
        earliest_alarm_timestamp_tomorrow: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('earliest_alarm_timestamp_tomorrow', none) if data is mapping else none }}
        debug_info: >
          {% set all_data_dict = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {% set output_dict = {} %}
          {% if all_data_dict is mapping %}
            {% set output_dict = {
                'retrieved_alarm_count': all_data_dict.get('alarm_count', 'Error: key missing'),
                'retrieved_earliest_time': all_data_dict.get('earliest_alarm_time_tomorrow', 'Error: key missing'),
                'retrieved_entities_sample': (all_data_dict.get('alarm_entities', []) | list | first) if (all_data_dict.get('alarm_entities', []) | list | length > 0) else 'No entities',
                'all_alarms_data_is_map': true,
                'all_alarms_data_keys': all_data_dict.keys() | list,
                'current_sensor_state': states('sensor.sonos_alarms_for_tomorrow')
               } %}
          {% else %}
            {% set output_dict = {
                'retrieved_alarm_count': 'Error: all_alarms_data not a map',
                'retrieved_earliest_time': 'Error',
                'retrieved_entities_sample': 'Error',
                'all_alarms_data_is_map': false,
                'current_sensor_state': states('sensor.sonos_alarms_for_tomorrow')
               } %}
          {% endif %}
          {{ output_dict | to_json }}
        rooms: >
          {% set data = state_attr('sensor.sonos_alarms_for_tomorrow', 'all_alarms_data') %}
          {{ data.get('rooms', []) if data is mapping else [] }}

    - name: "Sonos Upcoming Alarms"
      unique_id: sonos_upcoming_alarms
      icon: mdi:alarm-multiple
      state: >
        {{ state_attr('sensor.sonos_upcoming_alarms', 'alarm_count') | default(0) }} upcoming alarm(s).
      attributes:
        all_alarms_data: >
          {%- set today_date_obj = now().date() -%}
          {%- set tomorrow_date_obj = (now() + timedelta(days=1)).date() -%}
          {%- set ns = namespace(collected_alarms = []) -%}
          {%- set now_dt = now() -%}

          {# DEBUG: Collect all sonos_alarm_ entities and their attributes for troubleshooting #}
          {%- set debug_alarm_entities = states.switch
              | selectattr('entity_id','search','sonos_alarm_')
              | map(attribute='attributes')
              | list -%}

          {# Iterate through Sonos alarm switches that have a 'time' attribute and are enabled #}
          {%- for alarm_entity in states.switch
              | selectattr('entity_id','search','sonos_alarm_')
              | selectattr('state','eq','on') -%}
            {%- set time_str = alarm_entity.attributes.get('time') -%}
            {%- if not time_str %}{% continue %}{% endif -%}

            {%- set recurrence = (alarm_entity.attributes.get('recurrence') | default('DAILY')) | upper -%}
            {%- set base_time = today_at(time_str) -%}

            {# Check recurrence for today and tomorrow only #}
            {%- for i in range(2) -%}
              {%- set check_datetime = base_time + timedelta(days=i) -%}
              {%- set weekday_sonos = check_datetime.isoweekday() % 7 -%} {# 0=Sun, 1=Mon, ..., 6=Sat #}
              {%- set day_matches_recurrence = false -%}

              {%- if recurrence == 'DAILY' %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence == 'WEEKDAYS' and 1 <= weekday_sonos <= 5 %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence == 'WEEKENDS' and (weekday_sonos == 0 or weekday_sonos == 6) %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- if recurrence.startswith('ON_') -%}
                {%- set days_in_recurrence = recurrence.split('_',1)[1] -%}
                {%- if weekday_sonos|string in days_in_recurrence %}{% set day_matches_recurrence = true %}{% endif -%}
              {%- endif -%}

              {# If the alarm is scheduled for this checked day and is in the future #}
              {%- if day_matches_recurrence and check_datetime > now_dt -%}
                {%- set alarm_item = {
                    'entity_id': alarm_entity.entity_id,
                    'time': time_str,
                    'friendly_name': alarm_entity.attributes.get('friendly_name') | default(alarm_entity.name),
                    'timestamp': check_datetime.timestamp(),
                    'date': check_datetime.date().isoformat(),
                    'recurrence': recurrence,
                    'room': area_name(alarm_entity.entity_id) | default('Unknown')
                } -%}
                {%- set ns.collected_alarms = ns.collected_alarms + [alarm_item] -%}
              {%- endif -%}
            {%- endfor -%}
          {%- endfor -%}

          {# Post-loop processing #}
          {%- set sorted_alarms = ns.collected_alarms | sort(attribute='timestamp') -%}
          {%- set earliest_alarm_item = (sorted_alarms | first) if sorted_alarms else none -%}
          {%- set earliest_ts = earliest_alarm_item.timestamp if earliest_alarm_item else none -%}
          {%- set earliest_dt_local = as_datetime(earliest_ts) if earliest_ts is not none else none %}

          {%- set output_data = {
              'alarm_count': sorted_alarms | length,
              'alarm_entities': sorted_alarms | map(attribute='entity_id') | list,
              'friendly_names': sorted_alarms | map(attribute='friendly_name') | list,
              'rooms': sorted_alarms | map(attribute='room') | unique | list,
              'earliest_alarm_timestamp': earliest_ts,
              'earliest_alarm_time': earliest_dt_local.strftime('%Y-%m-%d %H:%M:%S') if earliest_dt_local else 'None',
              'raw_alarm_list_sorted': sorted_alarms,
              'debug_today_date_obj': today_date_obj.isoformat(),
              'debug_tomorrow_date_obj': tomorrow_date_obj.isoformat(),
              'debug_processing_time_utc': now().isoformat(),
              'debug_all_alarm_entities': debug_alarm_entities
          } -%}
          {{- output_data -}}
        alarm_count: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('alarm_count', 0) if data is mapping else 0 }}
        alarm_entities: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('alarm_entities', []) if data is mapping else [] }}
        friendly_names: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('friendly_names', []) if data is mapping else [] }}
        earliest_alarm_time: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('earliest_alarm_time', 'None') if data is mapping else 'None' }}
        earliest_alarm_timestamp: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('earliest_alarm_timestamp', none) if data is mapping else none }}
        rooms: >
          {% set data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {{ data.get('rooms', []) if data is mapping else [] }}
        debug_info: >
          {% set all_data_dict = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') %}
          {% set output_dict = {} %}
          {% if all_data_dict is mapping %}
            {% set output_dict = {
                'retrieved_alarm_count': all_data_dict.get('alarm_count', 'Error: key missing'),
                'retrieved_earliest_time': all_data_dict.get('earliest_alarm_time', 'Error: key missing'),
                'retrieved_entities_sample': (all_data_dict.get('alarm_entities', []) | list | first) if (all_data_dict.get('alarm_entities', []) | list | length > 0) else 'No entities',
                'all_alarms_data_is_map': true,
                'all_alarms_data_keys': all_data_dict.keys() | list,
                'current_sensor_state': states('sensor.sonos_upcoming_alarms')
               } %}
          {% else %}
            {% set output_dict = {
                'retrieved_alarm_count': 'Error: all_alarms_data not a map',
                'retrieved_earliest_time': 'Error',
                'retrieved_entities_sample': 'Error',
                'all_alarms_data_is_map': false,
                'current_sensor_state': states('sensor.sonos_upcoming_alarms')
               } %}
          {% endif %}
          {{ output_dict | to_json }}

    - name: "Soonest Sonos Alarm Info"
      unique_id: soonest_sonos_alarm_info
      icon: mdi:alarm
      state: >
        {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
        {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
        {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
        {{ soonest.time if soonest is mapping and 'time' in soonest else 'unknown' }}
      attributes:
        entity_id: >
          {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
          {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
          {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
          {{ soonest.entity_id if soonest is mapping and 'entity_id' in soonest else none }}
        friendly_name: >
          {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
          {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
          {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
          {{ soonest.friendly_name if soonest is mapping and 'friendly_name' in soonest else 'Soonest Sonos Alarm Info' }}
        room: >
          {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
          {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
          {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
          {{ soonest.room if soonest is mapping and 'room' in soonest else 'Unknown' }}
        timestamp: >
          {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
          {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
          {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
          {{ soonest.timestamp if soonest is mapping and 'timestamp' in soonest else none }}
        debug_info: >
          {%- set all_data = state_attr('sensor.sonos_upcoming_alarms', 'all_alarms_data') | default({}, true) -%}
          {%- set alarms = all_data.get('raw_alarm_list_sorted', []) if all_data is mapping else [] -%}
          {%- set soonest = alarms[0] if alarms|length > 0 else none -%}
          {{ soonest | to_json if soonest is mapping else '{}' }}

    # -----------------------------------------------------------------------
    # Next Alarm Chip Status - for dashboard toggle chip
    # Shows the next alarm time and whether it's enabled/disabled
    # -----------------------------------------------------------------------
    - name: "Sonos Next Alarm Chip"
      unique_id: sonos_next_alarm_chip
      icon: >
        {% set entity_id = state_attr('sensor.soonest_sonos_alarm_info', 'entity_id') %}
        {% if entity_id and states(entity_id) == 'on' %}
          mdi:alarm
        {% elif entity_id and states(entity_id) == 'off' %}
          mdi:alarm-off
        {% else %}
          mdi:alarm-note-off
        {% endif %}
      state: >
        {% set entity_id = state_attr('sensor.soonest_sonos_alarm_info', 'entity_id') %}
        {% set time_str = states('sensor.soonest_sonos_alarm_info') %}
        {% if entity_id and time_str not in ['unknown', 'unavailable', ''] %}
          {% if states(entity_id) == 'on' %}
            {{ time_str }}
          {% else %}
            Off
          {% endif %}
        {% else %}
          None
        {% endif %}
      attributes:
        entity_id: >
          {{ state_attr('sensor.soonest_sonos_alarm_info', 'entity_id') }}
        is_enabled: >
          {% set entity_id = state_attr('sensor.soonest_sonos_alarm_info', 'entity_id') %}
          {{ entity_id and states(entity_id) == 'on' }}
        time: >
          {{ states('sensor.soonest_sonos_alarm_info') }}
        room: >
          {{ state_attr('sensor.soonest_sonos_alarm_info', 'room') | default('Unknown') }}
        friendly_name: >
          {{ state_attr('sensor.soonest_sonos_alarm_info', 'friendly_name') | default('No alarm') }}
        timestamp: >
          {{ state_attr('sensor.soonest_sonos_alarm_info', 'timestamp') }}
        hours_until: >
          {% set ts = state_attr('sensor.soonest_sonos_alarm_info', 'timestamp') %}
          {% if ts %}
            {{ ((ts - now().timestamp()) / 3600) | round(1) }}
          {% else %}
            0
          {% endif %}
        was_manually_disabled: >
          {% set toggled = states('input_text.sonos_manually_toggled_alarm') %}
          {% set entity_id = state_attr('sensor.soonest_sonos_alarm_info', 'entity_id') %}
          {{ toggled == entity_id and entity_id and states(entity_id) == 'off' }}
        display_text: >
          {% set entity_id = state_attr('sensor.soonest_sonos_alarm_info', 'entity_id') %}
          {% set time_str = states('sensor.soonest_sonos_alarm_info') %}
          {% set room = state_attr('sensor.soonest_sonos_alarm_info', 'room') | default('') %}
          {% if entity_id and time_str not in ['unknown', 'unavailable', ''] %}
            {% if states(entity_id) == 'on' %}
              â° {{ time_str }}{% if room %} ({{ room }}){% endif %}
            {% else %}
              ðŸ”• {{ time_str }} OFF
            {% endif %}
          {% else %}
            No alarms
          {% endif %}

    - name: "Sonos Current Playing Group Coordinator"
      unique_id: sonos_current_playing_group
      icon: mdi:speaker-multiple
      state: >
        {% set playing = states.media_player
             | selectattr('attributes.group_members', 'defined')
             | selectattr('state', 'eq', 'playing')
             | map(attribute='entity_id')
             | list %}
        {{ playing[0] if playing|length > 0 else 'none' }}
      attributes:
        playing_state: >
          {% set playing = states.media_player
               | selectattr('attributes.group_members', 'defined')
               | selectattr('state', 'eq', 'playing')
               | list %}
          {{ playing[0].state if playing|length > 0 else 'idle' }}
        media_title: >
          {% set playing = states.media_player
               | selectattr('attributes.group_members', 'defined')
               | selectattr('state', 'eq', 'playing')
               | list %}
          {{ playing[0].attributes.media_title | default('', true) if playing|length > 0 else '' }}
        media_artist: >
          {% set playing = states.media_player
               | selectattr('attributes.group_members', 'defined')
               | selectattr('state', 'eq', 'playing')
               | list %}
          {{ playing[0].attributes.media_artist | default('', true) if playing|length > 0 else '' }}
        source: >
          {% set playing = states.media_player
               | selectattr('attributes.group_members', 'defined')
               | selectattr('state', 'eq', 'playing')
               | list %}
          {{ playing[0].attributes.source | default('', true) if playing|length > 0 else '' }}
        room: >
          {% set playing = states.media_player
               | selectattr('attributes.group_members', 'defined')
               | selectattr('state', 'eq', 'playing')
               | list %}
          {{ playing[0].name if playing|length > 0 else '' }}
        volume: >
          {% set playing = states.media_player
               | selectattr('attributes.group_members', 'defined')
               | selectattr('state', 'eq', 'playing')
               | list %}
          {{ playing[0].attributes.volume_level | float(0) if playing|length > 0 else 0 }}
        group_members: >
          {% set playing = states.media_player
               | selectattr('attributes.group_members', 'defined')
               | selectattr('state', 'eq', 'playing')
               | list %}
          {{ playing[0].attributes.group_members | default([], true) if playing|length > 0 else [] }}

    - name: "Sonos Living Room Group Label"
      unique_id: sonos_living_room_group_label
      icon: mdi:account-multiple-outline
      state: >
        {% set group = state_attr('media_player.living_room', 'group_members') or [] %}
        {% if group | length <= 1 %}
          Not grouped
        {% else %}
          {% set others = group | reject('eq', 'media_player.living_room') | list %}
          {% set names = expand(others) | map(attribute='name') | list %}
          In group with: {{ names | join(', ') }}
        {% endif %}

    - name: "Sonos Dining Room Group Label"
      unique_id: sonos_dining_room_group_label
      icon: mdi:account-multiple-outline
      state: >
        {% set group = state_attr('media_player.dining_room', 'group_members') or [] %}
        {% if group | length <= 1 %}
          Not grouped
        {% else %}
          {% set others = group | reject('eq', 'media_player.dining_room') | list %}
          {% set names = expand(others) | map(attribute='name') | list %}
          In group with: {{ names | join(', ') }}
        {% endif %}

    - name: "Sonos Kitchen Group Label"
      unique_id: sonos_kitchen_group_label
      icon: mdi:account-multiple-outline
      state: >
        {% set group = state_attr('media_player.kitchen', 'group_members') or [] %}
        {% if group | length <= 1 %}
          Not grouped
        {% else %}
          {% set others = group | reject('eq', 'media_player.kitchen') | list %}
          {% set names = expand(others) | map(attribute='name') | list %}
          In group with: {{ names | join(', ') }}
        {% endif %}

    - name: "Sonos Bath Group Label"
      unique_id: sonos_bath_group_label
      icon: mdi:account-multiple-outline
      state: >
        {% set group = state_attr('media_player.bath', 'group_members') or [] %}
        {% if group | length <= 1 %}
          Not grouped
        {% else %}
          {% set others = group | reject('eq', 'media_player.bath') | list %}
          {% set names = expand(others) | map(attribute='name') | list %}
          In group with: {{ names | join(', ') }}
        {% endif %}

    - name: "Sonos Bedroom Group Label"
      unique_id: sonos_bedroom_group_label
      icon: mdi:account-multiple-outline
      state: >
        {% set group = state_attr('media_player.bedroom', 'group_members') or [] %}
        {% if group | length <= 1 %}
          Not grouped
        {% else %}
          {% set others = group | reject('eq', 'media_player.bedroom') | list %}
          {% set names = expand(others) | map(attribute='name') | list %}
          In group with: {{ names | join(', ') }}
        {% endif %}

  binary_sensor:
    - name: "Sonos Living Room In Playing Group"
      unique_id: sonos_living_room_in_playing_group
      icon: mdi:speaker
      state: >
        {% set target = 'media_player.living_room' %}
        {% set main_group = states('sensor.sonos_current_playing_group_coordinator') %}
        {% if main_group == 'none' %}
          false
        {% else %}
          {% set members = state_attr(main_group, 'group_members') or [] %}
          {{ target in members }}
        {% endif %}

    - name: "Sonos Dining Room In Playing Group"
      unique_id: sonos_dining_room_in_playing_group
      icon: mdi:speaker
      state: >
        {% set target = 'media_player.dining_room' %}
        {% set main_group = states('sensor.sonos_current_playing_group_coordinator') %}
        {% if main_group == 'none' %}
          false
        {% else %}
          {% set members = state_attr(main_group, 'group_members') or [] %}
          {{ target in members }}
        {% endif %}

    - name: "Sonos Kitchen In Playing Group"
      unique_id: sonos_kitchen_in_playing_group
      icon: mdi:speaker
      state: >
        {% set target = 'media_player.kitchen' %}
        {% set main_group = states('sensor.sonos_current_playing_group_coordinator') %}
        {% if main_group == 'none' %}
          false
        {% else %}
          {% set members = state_attr(main_group, 'group_members') or [] %}
          {{ target in members }}
        {% endif %}

    - name: "Sonos Bath In Playing Group"
      unique_id: sonos_bath_in_playing_group
      icon: mdi:speaker
      state: >
        {% set target = 'media_player.bath' %}
        {% set main_group = states('sensor.sonos_current_playing_group_coordinator') %}
        {% if main_group == 'none' %}
          false
        {% else %}
          {% set members = state_attr(main_group, 'group_members') or [] %}
          {{ target in members }}
        {% endif %}

    - name: "Sonos Bedroom In Playing Group"
      unique_id: sonos_bedroom_in_playing_group
      icon: mdi:speaker
      state: >
        {% set target = 'media_player.bedroom' %}
        {% set main_group = states('sensor.sonos_current_playing_group_coordinator') %}
        {% if main_group == 'none' %}
          false
        {% else %}
          {% set members = state_attr(main_group, 'group_members') or [] %}
          {{ target in members }}
        {% endif %}

    # ------------------------------------------------------------------
    # Sonos Playing Status (for OAL dashboard)
    # FIX: Use entity.name instead of entity_id since Sonos is in friendly_name
    # ------------------------------------------------------------------
    - name: "Sonos Playing Status"
      unique_id: sonos_playing_status
      icon: mdi:speaker-multiple
      state: >
        {% set playing = namespace(rooms=[]) %}
        {% for entity in states.media_player
           if 'sonos' in entity.name | lower
           and entity.state == 'playing' %}
          {% set room_name = entity.name | replace(' Sonos', '') | replace(' Soundbar', '') | replace(' TV ', '') %}
          {% set playing.rooms = playing.rooms + [room_name] %}
        {% endfor %}
        {% if playing.rooms | length == 0 %}
          Off
        {% elif playing.rooms | length == 1 %}
          {{ playing.rooms[0] }}
        {% else %}
          {{ playing.rooms | length }} rooms
        {% endif %}
      attributes:
        playing_rooms: >
          {% set playing = namespace(rooms=[]) %}
          {% for entity in states.media_player
             if 'sonos' in entity.name | lower
             and entity.state == 'playing' %}
            {% set playing.rooms = playing.rooms + [entity.entity_id] %}
          {% endfor %}
          {{ playing.rooms }}
        is_playing: >
          {% set count = namespace(n=0) %}
          {% for entity in states.media_player
             if 'sonos' in entity.name | lower
             and entity.state == 'playing' %}
            {% set count.n = count.n + 1 %}
          {% endfor %}
          {{ count.n > 0 }}

############################
#  SCRIPTS                 #
############################

script:
  sonos_toggle_group_membership:
    alias: Sonos - Toggle Room In Current Group (with fallback)
    mode: queued
    fields:
      target_speaker:
        description: Sonos speaker to toggle
        example: media_player.kitchen
    sequence:
      - variables:
          fallback_hub: "media_player.living_room"
          target_speaker: "{{ target_speaker }}"
          playing_group: "{{ states('sensor.sonos_current_playing_group_coordinator') }}"

          # Step 1 â€“ decide the hub candidate (playing coordinator or LR)
          hub_candidate: >-
            {% if playing_group not in ['none', 'unknown', 'unavailable', ''] %}
              {{ playing_group }}
            {% else %}
              {{ fallback_hub }}
            {% endif %}

          # Step 2 â€“ from the hub candidate, derive the real coordinator
          # If the candidate is in a Sonos group, coordinator is group_members[0]; else the candidate itself
          hub_members_raw: >-
            {% set m = state_attr(hub_candidate, 'group_members') %}
            {{ m if m is not none else [hub_candidate] }}
          main_group_coordinator: >-
            {{ hub_members_raw[0] if hub_members_raw | length > 0 else hub_candidate }}

          # Step 3 â€“ group membership snapshot for the coordinator's group
          main_group_members: >-
            {% set members = state_attr(main_group_coordinator, 'group_members') %}
            {{ members if members is not none else [main_group_coordinator] }}

      - choose:
          # Case 1: target is already in the main group and the group has >1 member â†’ unjoin just that room
          - conditions:
              - condition: template
                value_template: >
                  {{ target_speaker in main_group_members and (main_group_members | length) > 1 }}
            sequence:
              - service: media_player.unjoin
                target:
                  entity_id: "{{ target_speaker }}"
              - service: logbook.log
                data:
                  name: "Sonos toggle"
                  message: >-
                    Unjoin {{ target_speaker }} from {{ main_group_coordinator }}.
                    Members before: {{ main_group_members }}

          # Case 2: target is in the main group but is the only member â†’ no-op
          - conditions:
              - condition: template
                value_template: >
                  {{ target_speaker in main_group_members and (main_group_members | length) == 1 }}
            sequence:
              - service: logbook.log
                data:
                  name: "Sonos toggle"
                  message: >-
                    No-op for {{ target_speaker }} â€“ only member in {{ main_group_coordinator }}.
                    Members before: {{ main_group_members }}

        # Case 3 (default): target is not in the main group â†’ join it
        default:
          - service: media_player.join
            target:
              entity_id: "{{ main_group_coordinator }}"
            data:
              group_members: >-
                {% set new_members = (main_group_members + [target_speaker]) | unique | list %}
                {{ new_members }}
          - service: logbook.log
            data:
              name: "Sonos toggle"
              message: >-
                Join {{ target_speaker }} to {{ main_group_coordinator }}.
                Members before: {{ main_group_members }}

  sonos_group_all_to_playing:
    alias: Sonos - Group all to current playing or Living Room hub
    mode: single
    sequence:
      - variables:
          fallback_hub: "media_player.living_room"
          playing_group: "{{ states('sensor.sonos_current_playing_group_coordinator') }}"
          all_speakers:
            - media_player.living_room
            - media_player.dining_room
            - media_player.kitchen
            - media_player.bath
            - media_player.bedroom

          # Same hub/coord logic as toggle, for consistency
          hub_candidate: >-
            {% if playing_group not in ['none', 'unknown', 'unavailable', ''] %}
              {{ playing_group }}
            {% else %}
              {{ fallback_hub }}
            {% endif %}
          hub_members_raw: >-
            {% set m = state_attr(hub_candidate, 'group_members') %}
            {{ m if m is not none else [hub_candidate] }}
          main_group_coordinator: >-
            {{ hub_members_raw[0] if hub_members_raw | length > 0 else hub_candidate }}
          main_group_members_before: >-
            {% set members = state_attr(main_group_coordinator, 'group_members') %}
            {{ members if members is not none else [main_group_coordinator] }}

      - service: media_player.join
        target:
          entity_id: "{{ main_group_coordinator }}"
        data:
          group_members: "{{ all_speakers }}"

      - service: logbook.log
        data:
          name: "Sonos group-all"
          message: >-
            Group all speakers to {{ main_group_coordinator }}.
            Members before: {{ main_group_members_before }}.
            All speakers: {{ all_speakers }}



  # 4) Ungroup all speakers
  sonos_ungroup_all:
    alias: Sonos - Ungroup All Speakers
    mode: single
    sequence:
      - service: media_player.unjoin
        target:
          entity_id:
            - media_player.living_room
            - media_player.dining_room
            - media_player.kitchen
            - media_player.bath
            - media_player.bedroom

  # 5) Pause all speakers
  sonos_all_pause:
    alias: Sonos - Pause All Speakers
    mode: single
    sequence:
      - service: media_player.media_pause
        target:
          entity_id:
            - media_player.living_room
            - media_player.dining_room
            - media_player.kitchen
            - media_player.bath
            - media_player.bedroom


  confirmable_notification:
    alias: Generic Confirmable Notification
    mode: parallel # Allows multiple notifications to be handled concurrently
    icon: mdi:message-alert-outline
    fields:
      notify_device:
        description: "The target notification device ID. Defaults to input_text.notify_target_device_id if not provided or invalid."
        example: "mobile_app_your_device_id"
      title:
        description: "The title of the notification."
        example: "Confirm Action"
      message:
        description: "The main message body of the notification."
        example: "Do you want to proceed?"
      confirm_text:
        description: "Text for the confirmation button."
        example: "Yes, Proceed"
      confirm_actions:
        description: "A list of actions (service calls) to perform on confirmation."
        example: |
          - service: light.turn_on
            target:
              entity_id: light.living_room
      dismiss_text:
        description: "Text for the dismissal button."
        example: "No, Cancel"
      dismiss_actions:
        description: "A list of actions (service calls) to perform on dismissal (optional)."
        example: |
          - service: script.log_dismissal
      timeout_actions:
        description: "A list of actions (service calls) to perform on timeout (optional)."
        example: |
          - service: system_log.write
            data:
              message: "Notification timed out by script."
      timeout_seconds:
        description: "Timeout in seconds to wait for a response."
        example: 3600
        default: 3600 # Default to 1 hour
      notification_tag:
        description: "Optional tag for the notification (e.g., for replacing or clearing)."
        example: "confirm_power_off"
    sequence:
      - variables:
          action_confirm_event: "{{ 'CONFIRM_EVENT_' ~ context.id }}"
          action_dismiss_event: "{{ 'DISMISS_EVENT_' ~ context.id }}"
          effective_notify_device: >
            {% if notify_device is defined and notify_device not in ['', none, 'unavailable', 'unknown'] %}
              {{ notify_device }}
            {% else %}
              {{ states('input_text.notify_target_device_id') }}
            {% endif %}
          effective_tag: >
            {% if notification_tag is defined and notification_tag | string | length > 0 %}
              {{ notification_tag }}
            {% else %}
              {{ 'confirmable_notification_' ~ context.id.split('.')[0] }}
            {% endif %}

      - condition: template
        value_template: "{{ effective_notify_device not in ['', none, 'unavailable', 'unknown'] }}"
        alias: "Check if target device ID is valid"

      - service: notify.notify
        data:
          title: "{{ title }}"
          message: "{{ message }}"
          data:
            tag: "{{ effective_tag }}"
            actions:
              - action: "{{ action_confirm_event }}"
                title: "{{ confirm_text }}"
              - action: "{{ action_dismiss_event }}"
                title: "{{ dismiss_text }}"

      - wait_for_trigger:
          - platform: event
            event_type: mobile_app_notification_action
            event_data:
              action: "{{ action_confirm_event }}"
          - platform: event
            event_type: mobile_app_notification_action
            event_data:
              action: "{{ action_dismiss_event }}"
        timeout:
          seconds: "{{ timeout_seconds }}"
        continue_on_timeout: true

      - choose:
          - conditions: "{{ wait.trigger and wait.trigger.event.data.action == action_confirm_event }}"
            alias: "User confirmed"
            sequence:
              - repeat:
                  for_each: "{{ confirm_actions | default([]) }}"
                  sequence:
                    - service: "{{ repeat.item.service }}"
                      data: "{{ repeat.item.data | default({}) }}"
                      target: "{{ repeat.item.target | default({}) }}"
              - service: notify.notify
                data:
                  message: "Confirmed: {{ title }}."
                  data:
                    tag: "{{ effective_tag }}_receipt"

          - conditions: "{{ wait.trigger and wait.trigger.event.data.action == action_dismiss_event }}"
            alias: "User dismissed"
            sequence:
              - repeat:
                  for_each: "{{ dismiss_actions | default([]) }}"
                  sequence:
                    - service: "{{ repeat.item.service }}"
                      data: "{{ repeat.item.data | default({}) }}"
                      target: "{{ repeat.item.target | default({}) }}"
              - service: notify.notify
                data:
                  message: "Dismissed: {{ title }}."
                  data:
                    tag: "{{ effective_tag }}_receipt"
        default: # Timeout
          - service: system_log.write
            data:
              message: "Confirmable notification '{{ title }}' timed out. Tag: {{ effective_tag }}"
              level: warning
          - repeat:
              for_each: "{{ timeout_actions | default([]) }}"
              sequence:
                - service: "{{ repeat.item.service }}"
                  data: "{{ repeat.item.data | default({}) }}"
                  target: "{{ repeat.item.target | default({}) }}"

  # --- Debug Sonos Alarms (Removed: now fully centralized in sensor) ---
  # debug_sonos_alarms script has been removed; use the centralized sensor for all alarm debug info.

  # --- Calculate Soonest Alarm and Update Helpers ---
  # DEPRECATED: update_soonest_sonos_alarm_info script is no longer needed.
  # update_soonest_sonos_alarm_info:
  #   alias: Update Soonest Sonos Alarm Info Helpers
  #   icon: mdi:alarm-sync
  #   mode: single
  #   sequence:
  #     - variables:
  #         debug_lines: "Debug output temporarily disabled for update_soonest_sonos_alarm_info."
  #         soonest_entity_id: "" # Placeholder
  #         next_alarm_date: "{{ now().strftime('%Y-%m-%d') }}" # Placeholder
  #         next_alarm_time: "00:00:00" # Placeholder
  #     - service: persistent_notification.create
  #       data:
  #         title: Sonos Alarm Debug (Update Script - TEMPORARILY SIMPLIFIED)
  #         message: "{{ debug_lines }}" 
  #         notification_id: sonos_alarm_update_debug_simplified
  #     - choose:
  #         - conditions:
  #             - condition: template # This will likely be false with placeholder
  #               value_template: "{{ soonest_entity_id | length > 0 }}" 
  #           sequence:
  #             - service: input_datetime.set_datetime
  #               target:
  #                 entity_id: input_datetime.soonest_sonos_alarm_timestamp
  #               data:
  #                 date: "{{ next_alarm_date }}" 
  #                 time: "{{ next_alarm_time }}" 
  #             - service: input_text.set_value
  #               target:
  #                 entity_id: input_text.soonest_sonos_alarm_entity_id
  #               data:
  #                 value: "{{ soonest_entity_id }}"
  #       default: # This will likely always run with placeholders
  #         - service: input_text.set_value
  #           target:
  #             entity_id: input_text.soonest_sonos_alarm_entity_id
  #           data:
  #             value: "None (update_soonest_sonos_alarm_info is simplified)"
  #         - service: input_datetime.set_datetime
  #           target:
  #             entity_id: input_datetime.soonest_sonos_alarm_timestamp
  #           data:
  #             date: "{{ now().strftime('%Y-%m-%d') }}"
  #             time: "00:00:01" 

  # --- Group all speakers and set baseline volume --------------------------
  # Using version from user-provided working script
  sonos_group_all_speakers_old:
    alias: Sonos Group All Speakers
    mode: single
    icon: mdi:speaker-multiple
    sequence:
      - condition: state
        entity_id: input_boolean.sonos_auto_group_enabled
        state: "on"
      - variables:
          master: >
            {{ expand('group.sonos_all') | selectattr('state','ne','unavailable') | map(attribute='entity_id') | first | default(none) }}
      - choose:
          - conditions: "{{ master != none }}"
            sequence:
              - service: media_player.join
                target: { entity_id: "{{ master }}" }
                data:
                  group_members: >
                    {{ expand('group.sonos_all') | selectattr('state','ne','unavailable') | map(attribute='entity_id') | list }}
              - service: media_player.volume_set
                target:
                  entity_id: >
                    {{ expand('group.sonos_all') | selectattr('state','ne','unavailable') | map(attribute='entity_id') | list }}
                data:
                  volume_level: "{{ states('input_number.sonos_default_volume') | float(0.2) }}"
        default:
          - service: system_log.write
            data:
              message: "Sonos Group All: Could not find an available master speaker in group.sonos_all."
              level: warning

  # --- Disable only the alarms that ring tomorrow --------------------------
  # LOGIC MATCHES EVENING ALARM CHECK NOTIFICATION EXACTLY
  disable_tomorrows_sonos_alarms:
    alias: Disable Tomorrow's Sonos Alarms
    mode: single
    icon: mdi:alarm-off
    sequence:
      - variables:
          alarms_to_disable: >
            {{ state_attr('sensor.sonos_upcoming_alarms', 'alarm_entities') | default([]) }}
          # Build a comma-separated string of entity_ids up to 255 chars
          max_chars: 255
          entity_ids_str: >
            {%- set ns = namespace(s='') -%}
            {%- for eid in alarms_to_disable -%}
              {%- set next = (ns.s ~ (',' if ns.s else '') ~ eid) -%}
              {%- if next | length <= max_chars -%}
                {%- set ns.s = next -%}
              {%- else -%}
                {%- break -%}
              {%- endif -%}
            {%- endfor -%}
            {{ ns.s }}
          skipped_alarms: >
            {%- set ns = namespace(s='') -%}
            {%- set used = entity_ids_str.split(',') if entity_ids_str else [] -%}
            {%- for eid in alarms_to_disable -%}
              {%- if eid not in used -%}
                {%- set ns.s = ns.s ~ (',' if ns.s else '') ~ eid -%}
              {%- endif -%}
            {%- endfor -%}
            {{ ns.s }}
      - service: input_text.set_value
        target:
          entity_id: input_text.sonos_alarms_disabled_for_tomorrow
        data:
          value: "{{ entity_ids_str }}"
      - service: system_log.write
        data:
          message: |
            Sonos Alarm Disable Debug: Alarms to disable (from centralized sensor): {{ alarms_to_disable }}. Stored: {{ entity_ids_str }}. Skipped (due to 255-char limit): {{ skipped_alarms }}
          level: info
      - choose:
          - conditions: "{{ entity_ids_str | count > 0 }}"
            sequence:
              - service: switch.turn_off
                target:
                  entity_id: "{{ entity_ids_str.split(',') if entity_ids_str else [] }}"
              - service: system_log.write
                data:
                  message: "Disabled tomorrow's Sonos alarms: {{ entity_ids_str }}"
                  level: info
        default:
          - service: system_log.write
            data:
              message: "No active Sonos alarms found scheduled for tomorrow to disable."
              level: info

  # --- Nightly confirmable notification ---
  # UPDATED: Removed target from notify.notify calls. Uses simplified update script.
  evening_alarm_check_notification:
    alias: Evening Alarm Check Notification
    mode: single
    icon: mdi:bell-check-outline
    sequence:
      # Step 1: (No longer call update script, logic is centralized)
      # Step 2: Condition for notifications enabled
      - condition: state 
        entity_id: input_boolean.sonos_alarm_notifications
        state: "on"
      # Step 3: Define variables using the centralized sensor
      - variables:
          dev_id_check: "{{ states('input_text.notify_target_device_id') }}"
          alarms_for_tomorrow: >
            {{ state_attr('sensor.sonos_upcoming_alarms', 'alarm_entities') | default([]) }}
          count: "{{ state_attr('sensor.sonos_upcoming_alarms', 'alarm_count') | int(0) }}"
          earliest_time_str: "{{ state_attr('sensor.sonos_upcoming_alarms', 'earliest_alarm_time') | default('unknown') }}"
          notification_title: "Sonos Alarm Check (Tomorrow)"
          notification_message: >
            {{ count }} alarm{{ 's' if count != 1 else '' }} will ring tomorrow (earliest at {{ earliest_time_str }}). Disable them?
          action_confirm: "{{ 'SONOS_CONFIRM_' ~ context.id }}"
          action_dismiss: "{{ 'SONOS_DISMISS_' ~ context.id }}"
          confirm_button_text: "Disable"
          dismiss_button_text: "Keep Enabled"
      # Step 4: Check if there are alarms for tomorrow and if ANY device ID is set
      - condition: template
        value_template: >
          {{ count > 0 }}
      - condition: template
        value_template: "{{ dev_id_check != '' and dev_id_check != none and dev_id_check != 'unavailable' and dev_id_check != 'unknown' }}"
      # Step 5: Send the actionable notification
      - service: notify.notify
        data:
          title: "{{ notification_title }}"
          message: "{{ notification_message }}"
          data:
            actions:
              - action: "{{ action_confirm }}"
                title: "{{ confirm_button_text }}"
              - action: "{{ action_dismiss }}"
                title: "{{ dismiss_button_text }}"
      # Step 6: Wait for the user to tap an action
      - wait_for_trigger:
          - platform: event
            event_type: mobile_app_notification_action
            event_data:
              action: "{{ action_confirm }}"
          - platform: event
            event_type: mobile_app_notification_action
            event_data:
              action: "{{ action_dismiss }}"
        timeout: 
          hours: 1
        continue_on_timeout: false 
      # Step 7: Perform action based on the trigger
      - choose:
          - conditions: "{{ wait.trigger and wait.trigger.event.data.action == action_confirm }}"
            sequence:
              - service: script.disable_tomorrows_sonos_alarms
              - service: notify.notify 
                data:
                  message: "OK, tomorrow's Sonos alarms have been disabled."
          - conditions: "{{ wait.trigger and wait.trigger.event.data.action == action_dismiss }}"
            sequence:
              - service: notify.notify 
                data:
                  message: "OK, tomorrow's Sonos alarms will remain enabled."
        default: 
          - service: system_log.write
            data:
              message: "Sonos alarm notification confirmation timed out."
              level: warning
      # Step 8: Log if no alarms were found initially
      - condition: template 
        value_template: >
          {{ count == 0 }}
      - service: system_log.write
        data:
          message: "Evening Alarm Check: No Sonos alarms found scheduled for tomorrow (count was {{ count }})."
          level: info

  # --- Apple TV Auto Off Notification Script (with configurable entity IDs) ---
  apple_tv_auto_off_notification:
    alias: Apple TV Auto Off Notification
    mode: single
    icon: mdi:television-off
    fields:
      apple_tv_entity_id: # Field to accept from automation
        description: "The entity ID of the Apple TV that triggered the inactivity."
        example: "media_player.living_room_apple_tv"
      display_entity_id: # Field to accept from automation
        description: "The entity ID of the display associated with the Apple TV."
        example: "media_player.living_room_samsung_q60"
    sequence:
      - variables:
          dev_id: "{{ states('input_text.notify_target_device_id') }}"
          # Use entity_ids passed from automation via fields, otherwise fallback to global helpers
          # This makes the script more flexible if called directly, but automation should always provide them.
          effective_apple_tv_entity: "{{ apple_tv_entity_id if apple_tv_entity_id is defined else states('input_text.apple_tv_entity_id') }}"
          effective_display_entity: "{{ display_entity_id if display_entity_id is defined else states('input_text.apple_tv_display_entity_id') }}"
          apple_tv_friendly_name: "{{ state_attr(effective_apple_tv_entity, 'friendly_name') | default('The Apple TV') }}"

      - choose:
          # Condition 1: Check if a valid notification device ID is available
          - conditions:
              - condition: template
                value_template: "{{ dev_id != '' and dev_id != none and dev_id != 'unavailable' and dev_id != 'unknown' }}"
              # Condition 2: Check if the Apple TV entity to control is valid and not unavailable/unknown
              - condition: template
                value_template: "{{ effective_apple_tv_entity != '' and effective_apple_tv_entity != none and states(effective_apple_tv_entity) != 'unavailable' and states(effective_apple_tv_entity) != 'unknown' }}"
            sequence:
              - service: script.confirmable_notification
                data:
                  notify_device: "{{ dev_id }}" # Pass the target device ID
                  title: "{{ apple_tv_friendly_name }} Inactive"
                  message: "{{ apple_tv_friendly_name }} has been paused or idle for over 30 minutes. Would you like to turn it and the display off?"
                  confirm_text: "Yes, Turn Off"
                  confirm_actions: # Note: plural `confirm_actions`
                    - service: media_player.turn_off
                      target:
                        entity_id: "{{ effective_apple_tv_entity }}"
                    # Conditionally turn off display only if it's a valid entity and different from the Apple TV itself
                    - condition: template
                      value_template: >-
                        {{ effective_display_entity != '' and
                           effective_display_entity != none and
                           states(effective_display_entity) != 'unavailable' and
                           states(effective_display_entity) != 'unknown' and
                           effective_display_entity != effective_apple_tv_entity }}
                    - service: media_player.turn_off
                      target:
                        entity_id: "{{ effective_display_entity }}"
                  dismiss_text: "No, Keep On"
                  notification_tag: "apple_tv_auto_off_{{ effective_apple_tv_entity | replace('media_player.','') }}" # Unique tag per Apple TV
                  timeout_seconds: 1800 # 30 minutes timeout for this specific notification
                  # timeout_actions and dismiss_actions can be added here if needed
        default:
          - service: system_log.write
            data:
              message: "Apple TV Auto Off Notification: Not sent. Invalid notify_device ('{{ dev_id }}') or Apple TV entity ('{{ effective_apple_tv_entity }}')."
              level: warning

  soonest_sonos_alarm_info:
    alias: Soonest Sonos Alarm Info
    mode: single
    icon: mdi:alarm
    sequence:
      - variables:
          alarms: >
            {{ state_attr('sensor.sonos_upcoming_alarms', 'raw_alarm_list_sorted') | default([], true) }}
          soonest_alarm: >
            {{ alarms[0] if alarms|length > 0 else none }}
          soonest_entity_id: >
            {{ soonest_alarm.entity_id if soonest_alarm is mapping and 'entity_id' in soonest_alarm else 'None' }}
          soonest_time: >
            {{ soonest_alarm.time if soonest_alarm is mapping and 'time' in soonest_alarm else 'None' }}
          soonest_room: >
            {{ soonest_alarm.room if soonest_alarm is mapping and 'room' in soonest_alarm else 'Unknown' }}
          soonest_friendly_name: >
            {{ soonest_alarm.friendly_name if soonest_alarm is mapping and 'friendly_name' in soonest_alarm else soonest_entity_id }}
      - service: system_log.write
        data:
          message: |
            Soonest Sonos Alarm Info: Entity: {{ soonest_entity_id }}, Time: {{ soonest_time }}, Room: {{ soonest_room }}, Name: {{ soonest_friendly_name }}
          level: info

  # -----------------------------------------------------------------------
  # Toggle Next Alarm - for dashboard chip tap action
  # Toggles the soonest upcoming alarm on/off and tracks it for re-enabling
  # -----------------------------------------------------------------------
  sonos_toggle_next_alarm:
    alias: Sonos Toggle Next Alarm
    mode: single
    icon: mdi:alarm-check
    sequence:
      - variables:
          # Get the soonest alarm entity_id from the sensor
          alarm_entity_id: >
            {{ state_attr('sensor.soonest_sonos_alarm_info', 'entity_id') }}
          # Check if we have a previously toggled alarm to re-enable
          previously_toggled: >
            {{ states('input_text.sonos_manually_toggled_alarm') | default('', true) }}
          # Determine which entity to work with (previously toggled takes priority)
          target_entity: >
            {% if previously_toggled and previously_toggled not in ['', 'unknown', 'unavailable', 'None'] %}
              {{ previously_toggled }}
            {% else %}
              {{ alarm_entity_id }}
            {% endif %}
          # Check if target is currently enabled
          is_currently_enabled: >
            {{ target_entity and states(target_entity) == 'on' }}

      - choose:
          # Case 1: We have a previously disabled alarm - re-enable it
          - conditions:
              - condition: template
                value_template: >
                  {{ previously_toggled and previously_toggled not in ['', 'unknown', 'unavailable', 'None'] }}
            sequence:
              # Turn on the previously disabled alarm
              - service: switch.turn_on
                target:
                  entity_id: "{{ previously_toggled }}"
              # Clear the tracking helper
              - service: input_text.set_value
                target:
                  entity_id: input_text.sonos_manually_toggled_alarm
                data:
                  value: ""
              - service: system_log.write
                data:
                  message: "Sonos Toggle Next Alarm: Re-enabled {{ previously_toggled }}"
                  level: info

          # Case 2: No alarm found at all
          - conditions:
              - condition: template
                value_template: "{{ not alarm_entity_id or alarm_entity_id in ['None', none] }}"
            sequence:
              - service: system_log.write
                data:
                  message: "Sonos Toggle Next Alarm: No upcoming alarm found to toggle."
                  level: info

          # Case 3: Alarm is currently ON - disable it
          - conditions:
              - condition: template
                value_template: "{{ is_currently_enabled }}"
            sequence:
              # Store which alarm we're disabling
              - service: input_text.set_value
                target:
                  entity_id: input_text.sonos_manually_toggled_alarm
                data:
                  value: "{{ alarm_entity_id }}"
              # Turn off the alarm
              - service: switch.turn_off
                target:
                  entity_id: "{{ alarm_entity_id }}"
              - service: system_log.write
                data:
                  message: "Sonos Toggle Next Alarm: Disabled {{ alarm_entity_id }}"
                  level: info

        # Default: Alarm exists but is OFF and wasn't toggled by us - enable it
        default:
          - service: switch.turn_on
            target:
              entity_id: "{{ alarm_entity_id }}"
          - service: system_log.write
            data:
              message: "Sonos Toggle Next Alarm: Enabled {{ alarm_entity_id }}"
              level: info

############################
#  AUTOMATION              #
############################
automation:
  - alias: Sonos - Group selector dropdown handler
    id: sonos_group_selector_dropdown_handler
    mode: queued
    trigger:
      - platform: state
        entity_id: input_select.sonos_group_selector
    condition:
      - condition: template
        value_template: >
          {{ trigger.to_state.state not in ['unknown', 'unavailable', 'Select room'] }}
    action:
      - variables:
          selected: "{{ trigger.to_state.state }}"
          target_speaker: >-
            {% if selected == 'Living' %}
              media_player.living_room
            {% elif selected == 'Dining' %}
              media_player.dining_room
            {% elif selected == 'Kitchen' %}
              media_player.kitchen
            {% elif selected == 'Bath' %}
              media_player.bath
            {% elif selected == 'Bedroom' %}
              media_player.bedroom
            {% else %}
              none
            {% endif %}
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ target_speaker != 'none' }}"
            sequence:
              - service: script.sonos_toggle_group_membership
                data:
                  target_speaker: "{{ target_speaker }}"
      - service: input_select.select_option
        target:
          entity_id: input_select.sonos_group_selector
        data:
          option: Select room
          
  # Event-based trigger for Sonos alarm updates
  - id: sonos_alarm_trigger_update
    alias: Sonos Alarm State Change Trigger Update
    description: "Updates soonest alarm info helpers when any Sonos alarm switch changes."
    mode: queued
    max_exceeded: silent
    trigger:
      - platform: state
        entity_id:
          - switch.sonos_alarm_living_room
          - switch.sonos_alarm_bedroom
          - switch.sonos_alarm_kitchen
          - switch.sonos_alarm_office
          - switch.sonos_alarm_bath
    condition: []
    action:
      # Removed deprecated script.update_soonest_sonos_alarm_info call
      - service: system_log.write
        data:
          message: "Sonos alarm update triggered by: {{ trigger.entity_id }}"
          level: info

  # Sonos nightly prompt automation
  - id: sonos_nightly_prompt
    alias: Sonos Nightly Alarm Prompt 21:30
    description: "Triggers the evening alarm check notification script daily."
    mode: single
    trigger:
      - platform: time
        at: "21:30:00"
    condition: [] # Conditions can be added here if needed
    action:
      - service: script.evening_alarm_check_notification

  # Apple TV Auto-Off Automation with configurable entity ID

  # Track last genuine Apple TV playback for debounce / session gating
  # NOTE: If you change input_text.apple_tv_entity_id, update entity_id here to match
  - id: apple_tv_track_last_playing
    alias: Apple TV Track Last Playing
    description: "Stores the last time Apple TV was in playing state"
    mode: restart
    trigger:
      - platform: state
        entity_id: media_player.living_room_apple_tv
        to: "playing"
    action:
      - service: input_datetime.set_datetime
        target:
          entity_id: input_datetime.apple_tv_last_playing
        data:
          datetime: "{{ now().isoformat() }}"

  - id: apple_tv_auto_off_after_inactivity
    alias: Apple TV Auto Off After Inactivity
    description: "Turns off Apple TV and display after 30 minutes of inactivity (paused/idle)."
    mode: single
    trigger:
      # Check every 5 minutes
      - platform: time_pattern
        minutes: "/5"
    condition:
      # AND conditions:
      - condition: state
        entity_id: input_boolean.apple_tv_no_auto_off
        state: 'off' # Only run if manual override is OFF
      # CORRECTED: Use template condition to check state of dynamic entity ID
      - condition: template
        value_template: >
          {% set apple_tv_id = states('input_text.apple_tv_entity_id') %}
          {% set display_id = states('input_text.apple_tv_display_entity_id') %}
          {% set apple_tv_state = states(apple_tv_id) %}
          {% set display_state = states(display_id) %}
          {% set apple_tv_obj = states[apple_tv_id] if apple_tv_id and apple_tv_state not in ['unavailable', 'unknown'] else none %}

          {# 1. Apple TV entity is valid and not unavailable/unknown/off/standby #}
          {% set apple_tv_valid = apple_tv_state not in ['unavailable', 'unknown', 'off', 'standby'] %}

          {# 2. Apple TV is paused or idle for 30+ minutes #}
          {% set is_inactive = apple_tv_obj is not none
                               and apple_tv_state in ['paused', 'idle']
                               and (now() - apple_tv_obj.last_changed).total_seconds() >= 1800 %}

          {# 3. TV display is actually ON #}
          {% set display_is_on = display_state not in ['unavailable', 'unknown', 'off', 'standby'] %}

          {# 4. Apple TV was genuinely playing recently (prevents phantom paused while TV left on) #}
          {% set last_playing = states('input_datetime.apple_tv_last_playing') %}
          {% set last_playing_ok = last_playing not in ['unknown','unavailable','none','']
                                   and (as_timestamp(now()) - as_timestamp(last_playing)) <= 12*3600 %}

          {{ apple_tv_valid and is_inactive and display_is_on and last_playing_ok }}
    action:
      - service: script.apple_tv_auto_off_notification
        data:
          # Pass the entity ID to the script if needed
          apple_tv_entity_id: "{{ states('input_text.apple_tv_entity_id') }}"
          display_entity_id: "{{ states('input_text.apple_tv_display_entity_id') }}"
      # Log the action taken
      - service: system_log.write
        data:
          message: "Apple TV Auto Off: Apple TV has been inactive for 30+ minutes. Notification sent."
          level: warning

  - id: sonos_reenable_tomorrows_alarms
    alias: Sonos Re-Enable Tomorrow's Alarms at 21:00
    description: "Re-enables Sonos alarms that were disabled for tomorrow."
    mode: single
    trigger:
      - platform: time
        at: "21:00:00"
    condition: []
    action:
      - variables:
          alarms_to_reenable: >
            {{ states('input_text.sonos_alarms_disabled_for_tomorrow').split(',') if states('input_text.sonos_alarms_disabled_for_tomorrow') else [] }}
      - choose:
          - conditions: "{{ alarms_to_reenable | count > 0 }}"
            sequence:
              - service: switch.turn_on
                target:
                  entity_id: "{{ alarms_to_reenable }}"
              - service: input_text.set_value
                target:
                  entity_id: input_text.sonos_alarms_disabled_for_tomorrow
                data:
                  value: ""
              - service: system_log.write
                data:
                  message: "Re-enabled Sonos alarms: {{ alarms_to_reenable }}"
                  level: info
        default:
          - service: system_log.write
            data:
              message: "No Sonos alarms to re-enable at 21:00."
              level: info
